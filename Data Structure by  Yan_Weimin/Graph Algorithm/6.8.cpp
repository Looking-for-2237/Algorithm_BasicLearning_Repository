#include <iostream>
using namespace std;
typedef char VerTexType;
typedef int ArcType;
#define MVNum 100
#define MaxInt 32767
struct
{
    VerTexType adjvex;
    ArcType lowcost;
} closedge[MVNum];
typedef struct
{
    VerTexType vexs[MVNum];
    ArcType arcs[MVNum][MVNum];
    int vexnum, arcnum;
} AMGraph;
int LocateVex(AMGraph G, VerTexType v)
{
    for (int i = 0; i < G.vexnum; ++i)
    {
        if (G.vexs[i] == v)
            return i;
    }
    return -1;
}
void CreateUDN(AMGraph &G)
{
    int i, j, k;
    cout << "Please enter the total number of vertices and edges (separated by a space):";
    cin >> G.vexnum >> G.arcnum;
    cout << endl;
    cout << "Enter the names of the vertices,e.g.'a'" << endl;
    for (i = 0; i < G.vexnum; ++i)
    {
        cout << "Enter the names of vertex" << (i + 1) << ":";
        cin >> G.vexs[i];
    }
    cout << endl;
    for (i = 0; i < G.vexnum; ++i)
    {
        for (j = 0; j < G.vexnum; ++j)
        {
            G.arcs[i][j] = MaxInt;
        }
    }
    cout << "Enter the edges and their weights,e.g.'a b 5'" << endl;
    for (k = 0; k < G.arcnum; ++k)
    {
        VerTexType v1, v2;
        ArcType w;
        cout << "Enter the two vertices and weight of edge" << (k + 1) << ":";
        cin >> v1 >> v2 >> w;
        i = LocateVex(G, v1);
        j = LocateVex(G, v2);
        G.arcs[i][j] = w;
        G.arcs[j][i] = G.arcs[i][j];
    }
}
int Min(AMGraph G)
{
    int i;
    int index = -1;
    int min = MaxInt;
    for (i = 0; i < G.vexnum; ++i)
    {
        if (min > closedge[i].lowcost && closedge[i].lowcost != 0)
        {
            min = closedge[i].lowcost;
            index = i;
        }
    }
    return index;
}
void MiniSpanTree_Prim(AMGraph G, VerTexType u)
{
    int k, j, i;
    VerTexType u0, v0;
    k = LocateVex(G, u);
    for (j = 0; j < G.vexnum; ++j)
    {
        if (j != k)
        {
            closedge[j].adjvex = u;
            closedge[j].lowcost = G.arcs[k][j];
        }
    }
    closedge[k].lowcost = 0;
    for (i = 1; i < G.vexnum; ++i)
    {
        k = Min(G);
        u0 = closedge[k].adjvex;
        v0 = G.vexs[k];
        cout << "Edge" << u0 << "--->" << v0 << endl;
        closedge[k].lowcost = 0; // add vertex k into U
        for (j = 0; j < G.vexnum; ++j)
        {
            if (G.arcs[k][j] < closedge[j].lowcost)
            {
                closedge[j].adjvex = G.vexs[k];
                closedge[j].lowcost = G.arcs[k][j];
            }
        }
    }
}
int main(void)
{
    cout << "************Algorithm 6.8:Prim's Algorithm**************" << endl
         << endl;
    AMGraph G;
    CreateUDN(G);
    cout << endl;
    cout << "Undirected graph G created successfully" << endl;
    cout << endl;
    cout << "***********Minimum Spanning Tree generated by Prim's Algorithm*********" << endl;
    MiniSpanTree_Prim(G, 'a');
    cout << endl;
    return 0;
}